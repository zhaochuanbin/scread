---
layout : post
title : "分布式事务"
category : java
tagline: ""
date : 2016-04-11
tags : [java,JVM]
---

### 两阶段提交
二阶段提交的算法思路：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。
二阶段提交其实就是实现XA分布式事物。两阶段提交保证了分布式事务的原子性，这些子事务要么都做，要么都不做。

#### 准备阶段
- 事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息;
- 每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志;

#### 提交阶段
- 协调者节点向所有参与者节点发出 提交/回滚的请求。
- 参与者节点正式提交/回滚操作，并释放在整个事务期间内占用的资源。
- 参与者节点向协调者节点发送提交/回滚消息
- 协调者节点受到所有参与者节点反馈的提交/回滚消息后，完成/取消事务

#### 缺点
**同步阻塞问题**:执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态
**单点故障**:协调者或参与者宕机

### 三阶段提交
3PC把2PC的准备阶段再次一分为二，CanCommit、PreCommit、DoCommit三个阶段。

#### CanCommit阶段
- 发送中断请求 协调者向所有参与者发送abort请求。
- 中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断
#### PreCommit阶段
**协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行**
- 发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
- 事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
- 响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。
**任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断**
- 发送中断请求 协调者向所有参与者发送abort请求。
- 中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断
#### doCommit阶段
- 发送提交/回滚请求 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求/发送abort请求。
- 事务提交/回滚 参与者接收到doCommit请求/abort请求之后，执行正式的事务提交/利用其在阶段二记录的undo信息来执行事务的回滚操作。并在完成事务提交之后释放所有事务资源。
- 响应反馈 事务提交完/回滚之后，向协调者发送Ack响应。
- 完成/回滚事务 协调者接收到所有参与者的ack响应之后，完成事务。

**在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交**

### 2PC与3PC的区别
- 3PC主要解决的单点故障问题，并减少阻塞。
- 因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。
- 由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况

### paxos算法
Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致
