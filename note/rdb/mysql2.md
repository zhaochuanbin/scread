### MYSQL逻辑架构
![](../images/mysql-logic.png)
第一层服务是基于网络的客户端/服务器的工具或者服务都有类似的架构。比如链接处理、授权认证、安全等。
第二层架构是MYSQL的核心服务功能，包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层事先：存储功能、触发器、视图等。
第三层包含了存储引擎。存储引起负责MYSQL中数据的存储和提取、每个引擎都有它的优势和劣势。服务器通过API和存储引擎进行同喜，这些接口屏蔽了不同引擎之间的差异，使得这些差异对上层的查询过程透明。

### 并发控制

读锁也叫共享锁，写锁也叫排它锁
读锁时共享的，或者说是相互不阻塞的，多个客户在同一时刻可以同时读取同一个资源，而互不干扰。
写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，基于安全策略的考虑，一个用户在执行写入时，并防止其他用户读取和写入的统一资源。
在加锁的同时也会消耗资源，锁的各种操作，包括获得锁、检查锁是否解除、释放锁都会增加系统的开销。
**表锁和行锁**
表锁时MYSQL中最基本的锁策略，并且是开销最小的策略。一个用户对表写操作会锁整张表，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级。
行锁可以最大程度的支持并发处理，同时也带来了最大的锁开销。MYSQL在InnoDB和XtraDB，以及其他存储引擎中实现了行级锁，行级锁只是在存储引擎中实现，而不是MYSQL服务器层中。服务器层完全不了解存储引擎中的锁实现，所有的存储引擎都已自己的方式显示了锁机制。

### 事务
事务是一组 原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部失败。
**ACID特性**
原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durablity)
**隔离级别**
READ UNCOMMITTED(读未提交)、READ COMMITTED(读已提交，解决脏读)、REPEATABLE READ(可重复读，解决不可重复度)、SERIZABLE(可串行化，解决幻读加锁读)
>SELECT [@global.tx_isolation | @@session.tx_isolation | @@tx_isolation;]; 
>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
InnoDB支持所有的隔离级别

**死锁**
死锁是两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，就可能产生死锁。
为解决这种问题，数据库系统直线了各种死锁检测和死锁超时机制。
InnoDB存储引擎，检查到死锁的循环依赖，并立即返回一个错误，这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种方法，及时当查询时间到达锁等待超时的设定后放弃锁清秋，这种方法通常来说不太好。InnoDB没有钱处理思索的方法是，将持有最少行级排他锁的事务进行回滚(这是相对简单的死锁回滚算法)。
**锁的行为和顺序和存储引擎相关的。死锁产生的双重原因：1、有些是因为真正的数据冲突，2、有些是由于存储引擎的实现方式导致的**

### MYSQL中的事务
MYSQL中的两种事务型存储引擎：InnoDB和NDB Cluster。另外还有一些第三方事务存储引擎：XtraDB和PBXT。
**MYSQL默认采用自动提交模式**
如果不是显式地开始一个事务，则每个查询都被当做一个事务执行提交操作。
通过AUTOCOMMIT变量来启用或禁用自动提交
>SHOW VARIABLES LIKE '%AUTOCOMMIT%';
SET AUTOCOMMIT = 1;

1或者ON表示启用，0或OFF表示禁用。当禁用时，所有查询都在一个事务中，知道显式的执行COMMIT提交或者ROLLBACK回滚，该事物结束，然后开始另一个新事物。

**在事务中不要混合使用存储引擎**
混合使用在查询的情况下没有问题，如果事务需要回滚，在非事务型表上就无法撤销。
在非事务型的表上执行事务相关操作的时候，MYSQL通常不会发出提醒，也不会报错，只有回滚的时候才会发出一个警告：“某些费是无形的表上的变更不能被回滚”。

**隐式和显式锁定**
